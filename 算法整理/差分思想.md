# 差分

- 前缀和求解数组不变的情况下，快速求解i --- j的区间的数组的和
- 差分数组是不断更改数组，在i---j区间内加上某个数字，求解变化后的数组

## 启发式

差分数组：b[n]
b[0] = a[0]
b[1] = a[1] - a[0] // 存储当前数字和前一个数字的差值
b[2] = a[2] - a[1] 

- 没有对原数组进行加法操作，复原到原来的数组

b[0] = b[0]
b[1] = b[0] + b[1]
b[2] = b[1] + b[2]

​		执行多个区间的加法，加入b数组所有元素就是全0，完成 {{2,1, 3}, {3, 2, 6}}，第一个参数是区间内每一个数要加的数字，后面两个数组分别是开始和结束的区间（下标从0开始）。执行以后如下：
0，2，5，5，3，3，3‘

## 利用差分的好处（下表从0开始,前缀和一般从1开始）

- 利用差分数组可以直接进行操作 b[1] += 2 ;  b[4] -= 2，这样累加后以后，相当于1-----3都会加2
- 因为最后"复原操作"要累加，只要b1加上2，计算累加的时候后面的b[2],b[3]也会加2，但是到了3下标之后，要减去2 

y总构造差分数组和完成差分数组的加法函数总结成了一个函数：
```cpp
void insert(vector<int> &arr, int l, int r, int number)
{
    arr[l] += number;
    if (r + 1 < arr.size()) // 好多实际应用要考虑越界
    {
        arr[r + 1] -= number;
    }
}
```
构造差分数组的时候完全可以复用上面的函数：
arr[l] += a[i]
arr[l + 1] -= a[i]
带入i = 0, i =1,你发现正好arr[0] = a[0],arr[1] = a[1] - a[0]..... 

## 1094

![image.png](https://cdn.nlark.com/yuque/0/2022/png/312760/1660137707801-a5a86669-ec35-455c-981b-531a31f42d41.png)

- 不用构造差分数组，差分数组全0
- 注意在to这个下车的时候，这里是开区间，比如上面[2,1,5]这里，到5的时候，这里已经下车了！！！

## 1109作为练习





